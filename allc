//1.a fibonacci series
#include <stdio.h>
int main() {
 int n,i;
 int t1 = 0, t2 = 1, nextTerm;
 printf("Enter the number of terms: ");
 scanf("%d", &n);
 printf("Fibonacci Series: ");
 for(i = 1; i <= n; i++) {
 printf("%d ", t1);
 nextTerm = t1 + t2; 
 t1 = t2; 
 t2 = nextTerm; 
 }
 printf("\n");
 return 0;
}
ALGO 1.a
Step 1: START 
Step 2: Declare n1, n2, n3  
Step 3: Initialize var 
Step 4: Enter the no. of terms for Fibonacci Series  
Step 5: n1 & n2  
Step 6: for loop (i=2; i<num; i++) n3=n2+n1 
n1=n2 N2=n3 
Step 7: print n3 Step 8: STOP

//1.b compare 3 numbers and find min and max
#include <stdio.h>
int main() {
 int num1, num2, num3;
 int max, min;
 printf("Enter three numbers: ");
 scanf("%d %d %d", &num1, &num2, &num3);
 max = min = num1;
 if(num2 > max) {
 max = num2;
 }
 if(num3 > max) {
 max = num3;
 }
 if(num2 < min) {
 min = num2;
 }
 if(num3 < min) {
 min = num3;
 }
 printf("Maximum number: %d\n", max);
 printf("Minimum number: %d\n", min);
 return 0;
}
ALGO 1.b
step1 start
step2 input 3 no. : num1,num2,num3
step3 initialise max = num1 and min = num1
step4 compare for max :: 1.if num2>max then max = num2
                         2.if num3>max then max = num3
step5 campare for min :: 1.if num2<min then min = num2
                         2.if num3<min then min = num3
step6 display max and min
step7 end

//2.a program to read marks of students of class and display it
#include <stdio.h>
int main() {
 int n, i;
 printf("Enter the number of students in the class: ");
 scanf("%d", &n);
 int marks[n];
 printf("Enter marks of %d students:\n", n);
 for(i = 0; i < n; i++) {
 printf("Student %d: ", i + 1);
 scanf("%d", &marks[i]);
 }
 printf("\nMarks of students in the class:\n");
 for(i = 0; i < n; i++) {
 printf("Student %d: %d\n", i + 1, marks[i]);
 }
 return 0;
}

Algorithm→2.a
Step1:Start
Step2:In put total number of students n

Step3:Declare on array marks [n]

Step4:For each student (i=o to n-1);
                        input marks [i]
Step5:For each Student (i=o to n-1);
Step6:End

//2.b  concept of 1d array and finding the sum of the array
#include <stdio.h>
int main()
{
    int n, i, sum = 0;
    printf("Enter the number of elements in the array: ");
    scanf("%d", &n);
    int arr[n]; 
    printf("Enter %d elements:\n", n);
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }
    
    for (i = 0; i < n; i++)
    {
        sum += arr[i]; // sum = sum + arr[i]
    }
    
    printf("The sum of the array elements is: %d\n", sum);
    return 0;
}

Algorithm→2.b
Step Start
Step 2: Input number of elementn.
Step 3: Declare array arr[n] and variable sum=0
Step 4: For each element (i=0 to 1):
               Input arr (ⅰ)
              Add arr (i) to sum
Step 5: Display total Sum
Step 6 END

//3.a write a program to add two matrix and display it
#include <stdio.h>

int main(void) {
    int a[3][3], b[3][3], c[3][3];
    int i, j, k;

    printf("\nEnter elements of Matrix A (3x3):\n");
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            scanf("%d", &a[i][j]);
        }
    }

    printf("\nEnter elements of Matrix B (3x3):\n");
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            scanf("%d", &b[i][j]);
        }
    }

    // Initialize Matrix C to 0
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            c[i][j] = 0;
        }
    }

    // Matrix Multiplication: C = A × B
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            for (k = 0; k < 3; k++) {
                c[i][j] += a[i][k] * b[k][j];
            }
        }
    }

    printf("\nResultant Matrix C (A × B):\n");
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            printf("%d\t", c[i][j]);
        }
        printf("\n");
    }

    return 0;
}

Algorithm→3.a
Step 1: Start
Step 2: Input number of rows (m) and columns (n)
Step 3: Declare two matrices A[m][n] and B[m][n]
Step 4: Declare result matrix C[m][n]
Step 5: Input elements of matrix A using loop
  for i = 0 to m-1
   for j = 0 to n-1
    Input A[i][j]
Step 6: Input elements of matrix B using loop
  for i = 0 to m-1
   for j = 0 to n-1
    Input B[i][j]
Step 7: Perform addition
  for i = 0 to m-1
   for j = 0 to n-1
    C[i][j] = A[i][j] + B[i][j]
Step 8: Display resultant matrix C
Step 9: Stop

//3.b write a program to implement matrix multiplication
#include <stdio.h>
int main() {
 int a[10][10], b[10][10], c[10][10];
 int r1, c1, r2, c2, i, j, k;
 // Input size of matrices
 printf("Enter rows and columns of first matrix: ");
 scanf("%d %d", &r1, &c1);
 printf("Enter rows and columns of second matrix: ");
 scanf("%d %d", &r2, &c2);
 // Condition check for multiplication
 if (c1 != r2) {
 printf("Matrix multiplication not possible! (Columns of A != Rows of B)\n");
 return 0;
 }
 // Input first matrix
 printf("\nEnter elements of first matrix (A):\n");
 for (i = 0; i < r1; i++) {
 for (j = 0; j < c1; j++) {
 scanf("%d", &a[i][j]);
 }
 }
 // Input second matrix
 printf("\nEnter elements of second matrix (B):\n");
 for (i = 0; i < r2; i++) {
 for (j = 0; j < c2; j++) {
     scanf("%d", &b[i][j]);
 }
 }
 // Initialize result matrix with 0
 for (i = 0; i < r1; i++) {
 for (j = 0; j < c2; j++) {
 c[i][j] = 0;
 }
 }
 // Matrix multiplication
 for (i = 0; i < r1; i++) {
 for (j = 0; j < c2; j++) {
 for (k = 0; k < c1; k++) {
 c[i][j] += a[i][k] * b[k][j];
 }
 }
 }
 // Print result
 printf("\nResultant Matrix (C = A * B):\n");
 for (i = 0; i < r1; i++) {
 for (j = 0; j < c2; j++) {
 printf("%d\t", c[i][j]);
 }
 printf("\n");
 }
 return 0;
}


Algorithm 3.b – Multiplication of two matrices
Step 1: Start
Step 2: Declare 2D arrays A[10][10], B[10][10] and C[10][10]
Step 3: Input rows (r1, r2) and columns (c1, c2) of both matrices
Step 4: Check condition
  If c1 ≠ r2 → Display “Multiplication not possible” and Stop
Step 5: Input elements of first matrix A
Step 6: Input elements of second matrix B
Step 7: Initialize all elements of C = 0
Step 8: Perform multiplication using triple nested loop
for i = 0 to r1-1
 for j = 0 to c2-1
  for k = 0 to c1-1
   C[i][j] = C[i][j] + A[i][k] * B[k][j]
Step 9: Display resultant matrix C
Step 10: Stop

//4.a linear search concept
#include <stdio.h>
struct student
{
    int rno;
    float cgpa;
} s[10]; // array of students
int main()
{

        int i,
        n, found = 0;
    float key = 9.5;

    printf("Enter number of students: ");
    scanf("%d", &n);

    // Input student details
    for (i = 0; i < n; i++)
    {
        printf("Enter Roll No and CGPA of Student[%d]: ", i + 1);
        scanf("%d %f", &s[i].rno, &s[i].cgpa);
    }

    printf("\nRoll No. of students having CGPA = %.1f:\n", key);

    // Linear search
    for (i = 0; i < n; i++)
    {
        if (s[i].cgpa == key)
        {
            printf("[%d]\n", s[i].rno);
            found = 1;
        }
    }

    if (found == 0)
    {
        printf("None of the students has CGPA = %.1f\n", key);
    }

    return 0;
}
Algorithm→4.a
Step 1: START 
Step 2: Define structure Step 
3: Declare an array  
Step 4: Input data…Use for loop 
Step 5: Search CGPA….Display the result  
Step 6: STOP 

// 4.b binary search concept
#include <stdio.h>
struct student
{
    int rno;
    float cgpa;
} s[5];

int main()
{
    int i;
    int mid, low, high, found = 0;
    printf("\nEnter Roll No and CGPA of 5 Students in ascending order:\n");
    for (i = 0; i < 5; i++)
    {
        printf("\nEnter Roll No and CGPA of Student[%d]:", i + 1);
        scanf("%d%f", &s[i].rno, &s[i].cgpa);
    }
    low = 0;
    high = 4;
    printf("\nRoll No. of students having CGPA equal to 6.0:\n");
    while (low <= high)
    {
        mid = (low + high) / 2;
        if (s[mid].cgpa == 6.00)
        {
            printf("\n[%d]", s[mid].rno);
            found = 1;
            break;
        }
        else if (s[mid].cgpa > 6.00)
        {
            high = mid - 1;
        }
        else // if (s[mid].cgpa<6.00)
        {
            low = mid + 1;
        }
    }
    if (found == 0)
    {
        printf("None of student is having CGPA equal to 6.00");
    }
}
Algorithm→4.b
Step 1: START 
Step 2: Define Structure 
Step 3: Declare mid, high, found  
Step 4: Use else if condition  
Step 5: Display the result 
Step 6: STOP

//5.a sort the age and arrange them in ascending order using bubble sort
#include <stdio.h>
#include <stdbool.h>

    void
    swap(int *a, int *b)
{
    int t = *a;
    *a = *b;
    *b = t;
}

void bubbleSort(int a[], int n)
{
    for (int i = 0; i < n - 1; i++)
    {
        bool swapped = false;
        for (int j = 0; j < n - 1 - i; j++)
        {
            if (a[j] > a[j + 1])
            {
                swap(&a[j], &a[j + 1]);
                swapped = true;
            }
        }
        if (!swapped)
            break; // already sorted
    }
}
int main()
{
    int n;
    printf("Enter number of applicants: ");
    if (scanf("%d", &n) != 1 || n <= 0)
    {
        printf("Invalid size.\n");
        return 0;
    }
    
    int ages[n];
    printf("Enter ages of applicants:\n");
    for (int i = 0; i < n; i++)
        scanf("%d", &ages[i]);

    bubbleSort(ages, n);

    printf("\nSorted ages in ascending order:\n");
    for (int i = 0; i < n; i++)
        printf("%d ", ages[i]);
    printf("\n");
    return 0;
}
Algorithm→5.a
Step 1: START 
Step 2: Initialize the array i.e. a[5] 
Step 3: Implement Bubble Sort in the code Step 4: Use 2 loop (i.e. of i & j) Step 
5: Display the sorted array Step 6: STOP

//5.b sort and arrange age using quick sort
#include <stdio.h>

// Function to swap two elements
void swap(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Partition function for Quick Sort
int partition(int arr[], int low, int high)
{
    int pivot = arr[high]; // Choosing the last element as pivot
    int i = (low - 1);

    for (int j = low; j < high; j++)
    {
        if (arr[j] <= pivot)
        { // If current element <= pivot
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]); // Place pivot in correct position
    return (i + 1);
}

// Quick Sort function
void quickSort(int arr[], int low, int high)
{
    if (low < high)
    {
        int pi = partition(arr, low, high);

        // Recursively sort elements before and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main()
{
    int n;
    printf("Enter number of applicants: ");
    scanf("%d", &n);
    int ages[n];
    printf("Enter ages of applicants:\n");
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &ages[i]);
    }
    quickSort(ages, 0, n - 1);
    printf("\nSorted ages for Passport Registration:\n");
    for (int i = 0; i < n; i++)
    {
        printf("%d ", ages[i]);
    }
    printf("\n");
    return 0;
}
Algorithm→5.b
Step 1: START 
Step 2: Declare variables n,i 
Step 3: Use for loop     
Step 4: Use quick sort 
Step 5: Display the sorted array 
Step 6: STOP

//6 push,pop operation on stack
#include <stdio.h>
#define MAX 5   // Maximum size of stack
int stack[MAX]; // Array to store stack elements
int top = -1;   // Top of stack initialized to -1 (empty stack)
// Function to push element onto stack
void push()
{
    int value;
    if (top == MAX - 1)
    {
        printf("Stack Overflow! Cannot push element.\n");
    }
    else
    {
        printf("Enter the value to push: ");
        scanf("%d", &value);
        top++;
        stack[top] = value;
        printf("%d pushed to stack.\n", value);
    }
}
// Function to pop element from stack
void pop()
{
    if (top == -1)
    {
        printf("Stack Underflow! No element to pop.\n");
    }
    else
    {
        printf("%d popped from stack.\n", stack[top]);
        top--;
    }
}
// Function to display stack elements
void display()
{
    if (top == -1)
    {
        printf("Stack is empty.\n");
    }
    else
    {
        printf("Stack elements: ");
        for (int i = top; i >= 0; i--)
        {
            printf("%d ", stack[i]);
        }
        printf("\n");
    }
}
int main()
{
    int choice;
    do
    {
        printf("\n--- Stack Operations ---\n");
        printf("1. Push\n2. Pop\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch (choice)
        {
        case 1:
            push();
            break;
        case 2:
            pop();
            break;
        case 3:
            display();
            break;
        case 4:
            printf("Exiting program.\n");
            break;
        default:
            printf("Invalid choice! Try again.\n");
        }
    } while (choice != 4);
    return 0;
}
Algorithm→6
Step 1: START 
Step 2: Initialize Variables: 
Step 3: Main Menu Loop: Display the menu options: PUSH, POP, DISPLAY, EXIT. 
Step 4: Push Operation (Case 1): 
Step 5: Pop Operation (Case 2): 
Step 6: Display Operation (Case 3): 
Step 7 : Exit Operation (Case 4): 
Step 8: STOP

//7.Write a program to implement enqueue and deque operations on Queue. 
#include <stdio.h>
#define MAX 5 // Maximum size of the queue

int queue[MAX]; // Array to store queue elements
int front = -1; // Front pointer
int rear = -1;  // Rear pointer
// Function to add element to the queue (Enqueue)
void enqueue()
{
    int value;
    if (rear == MAX - 1)
    {
        printf("Queue Overflow! Cannot insert element.\n");
    }
    else
    {
        printf("Enter the value to enqueue: ");
        scanf("%d", &value);
        if (front == -1)
        { // First element insertion
            front = 0;
        }
        rear++;
        queue[rear] = value;
        printf("%d added to the queue.\n", value);
    }
}
// Function to remove element from the queue (Dequeue)
void dequeue()
{
    if (front == -1 || front > rear)
    {
        printf("Queue Underflow! No element to dequeue.\n");
        front = -1; // Reset pointers when queue becomes empty
        rear = -1;
    }
    else
    {
        printf("%d removed from the queue.\n", queue[front]);
        front++;
    }
}
// Function to display the queue elements
void display()
{
    if (front == -1)
    {
        printf("Queue is empty.\n");
    }
    else
    {
        printf("Queue elements: ");
        for (int i = front; i <= rear; i++)
        {
            printf("%d ", queue[i]);
        }
        printf("\n");
    }
}
int main()
{
    int choice;
    do
    {
        printf("\n--- Queue Operations ---\n");
        printf("1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch (choice)
        {
        case 1:
            enqueue();
            break;
        case 2:
            dequeue();
            break;
        case 3:
            display();
            break;
        case 4:
            printf("Exiting program.\n");
            break;
        default:
            printf("Invalid choice! Try again.\n");
        }
    } while (choice != 4);
    return 0;
}
Algorithm→7
Step 1: START 
Step 2: Declare que[MAX], front, item, choice.  
Step 3: Initialize the above terms  
Step 4: Enter your choice 
Step 5: Declare a number of cases.  
Step 6: STOP

//8.Write a program to implement Singly Linked List for storing student PRN no.
#include <stdio.h>
#include <stdlib.h>

// Define a node srtructure
struct Node
{
    int prn;
    struct Node *next;
};
// Head pointer
struct Node *head = NULL;
// Function to create a new node
struct Node *createNode(int prn)
{
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->prn = prn;
    newNode->next = NULL;
    return newNode;
}
// Function to insert at the end
void insertAtEnd()
{
    int prn;
    printf("Enter student PRN to insert: ");
    scanf("%d", &prn);
    struct Node *newNode = createNode(prn);
    if (head == NULL)
    {
        head = newNode;
    }
    else
    {
        struct Node *temp = head;
        while (temp->next != NULL)
        {
            temp = temp->next;
        }
        temp->next = newNode;
    }
    printf("PRN %d inserted successfully.\n", prn);
}
// Function to delete a node by PRN
void deleteByPRN()
{
    if (head == NULL)
    {
        printf("List is empty. Cannot delete.\n");
        return;
    }
    int prn;
    printf("Enter PRN to delete: ");
    scanf("%d", &prn);
    struct Node *temp = head;
    struct Node *prev = NULL;
    while (temp != NULL && temp->prn != prn)
    {
        prev = temp;
        temp = temp->next;
    }
    if (temp == NULL)
    {
        printf("PRN %d not found in the list.\n", prn);
        return;
    }
    if (prev == NULL)
    {
        // Deleting head node
        head = temp->next;
    }
    else
    {
        prev->next = temp->next;
    }
    free(temp);
    printf("PRN %d deleted successfully.\n", prn);
}
// Function to display the linked list
void displayList()
{
    if (head == NULL)
    {
        printf("List is empty.\n");
        return;
    }
    printf("Student PRNs in the list: ");
    struct Node *temp = head;
    while (temp != NULL)
    {
        printf("%d -> ", temp->prn);
        temp = temp->next;
    }
    printf("NULL\n");
}
int main()
{
    int choice;
    do
    {
        printf("\n--- Singly Linked List Operations ---\n");
        printf("1. Insert PRN\n2. Delete PRN\n3. Display List\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch (choice)
        {
        case 1:
            insertAtEnd();
            break;
        case 2:
            deleteByPRN();
            break;
        case 3:
            displayList();
            break;
        case 4:
            printf("Exiting program.\n");
            break;
        default:
            printf("Invalid choice! Try again.\n");
        }
    } while (choice != 4);
    return 0;
}
Algorithm→8.a
Step 1: START 
Step 2: Define the structure node 
Step 3: Define function create(struct node *head) 
Step 4: Define the function insert_at_last(struct node *head) 
Step 5: Define a function void display( )  
Step 6: Define int main( )  
Step 7: STOP
Algorithm→8.b
Step 1: START 
Step 2: Define the structure node 
Step 3: Define function create(struct node *head) 
Step 4: Define the function insert_at_last(struct node *head) 
Step 5: Define a function del(struct node *head) 
Step 6: Define a function void display( )  
Step 7: Define int main( )  
Step 8: STOP 

//9. Write a program to implement Binary Tree.
#include <stdio.h>
#include <stdlib.h>
// Structure of a node in binary tree
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Inorder traversal (Left, Root, Right)
void inorder(struct Node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

// Preorder traversal (Root, Left, Right)
void preorder(struct Node* root) {
    if (root != NULL) {
        printf("%d ", root->data);
        preorder(root->left);
        preorder(root->right);
    }
}

// Postorder traversal (Left, Right, Root)
void postorder(struct Node* root) {
    if (root != NULL) {
        postorder(root->left);
        postorder(root->right);
        printf("%d ", root->data);
    }
}

// Insert node in binary tree (level order insertion)
struct Node* insert(struct Node* root, int value) {
    if (root == NULL) return createNode(value);

    struct Node* queue[100];
    int front = 0, rear = 0;
    queue[rear++] = root;

    while (front < rear) {
        struct Node* temp = queue[front++];

        if (temp->left == NULL) {
            temp->left = createNode(value);
            return root;
        } else {
            queue[rear++] = temp->left;
        }

        if (temp->right == NULL) {
            temp->right = createNode(value);
            return root;
        } else {
            queue[rear++] = temp->right;
        }
    }
    return root;
}

int main() {
    struct Node* root = NULL;
    int choice, value;

    do {
        printf("\n--- Binary Tree Operations ---\n");
        printf("1. Insert Node\n2. Inorder Traversal\n3. Preorder Traversal\n4. Postorder Traversal\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &value);
                root = insert(root, value);
                break;
            case 2:
                printf("Inorder Traversal: ");
                inorder(root);
                printf("\n");
                break;
            case 3:
                printf("Preorder Traversal: ");
                preorder(root);
                printf("\n");
                break;
            case 4:
                printf("Postorder Traversal: ");
                postorder(root);
                printf("\n");
                break;
            case 5:
                printf("Exiting program.\n");
                break;
            default:
                printf("Invalid choice! Try again.\n");
        }
    } while (choice != 5);

    return 0;
}
Algorithm→9
Step 1: START 
Step 2: Declare the structure Node with fields: data, left, right  
Step 3: Define a function createNode( ) 
Step 4: In the main() function: 
   Declare a pointer root, Set root to the result of createNode() 
Step 5: STOP 

